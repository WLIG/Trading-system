"""\n集成交易系统核心模块\n提供完整的量化交易功能\n"""\n\nimport time\nimport logging\nimport sqlite3\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Any, Tuple\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nimport requests\nimport json\n\n# 配置日志\nlogger = logging.getLogger(__name__)\n\nclass TradingMode(Enum):\n    """交易模式"""\n    BACKTEST = "backtest"\n    PAPER = "paper"\n    LIVE = "live"\n\nclass MessageType(Enum):\n    """消息类型"""\n    INFO = "info"\n    WARNING = "warning"\n    ERROR = "error"\n    TRADE = "trade"\n    SIGNAL = "signal"\n\n@dataclass\nclass TradingSignal:\n    """交易信号"""\n    signal: str  # BUY, SELL, HOLD\n    price: float\n    confidence: float\n    timestamp: datetime\n    reason: str\n    indicators: Dict[str, Any]\n\nclass DatabaseManager:\n    """数据库管理器"""\n    \n    def __init__(self, db_path: str = "trading_system.db"):\n        self.db_path = db_path\n        self.init_database()\n    \n    def init_database(self):\n        """初始化数据库"""\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        # 创建交易记录表\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS trades (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp TEXT NOT NULL,\n                symbol TEXT NOT NULL,\n                side TEXT NOT NULL,\n                quantity REAL NOT NULL,\n                price REAL NOT NULL,\n                value REAL NOT NULL,\n                commission REAL DEFAULT 0,\n                strategy TEXT,\n                signal_confidence REAL\n            )\n        ''')\n        \n        # 创建信号记录表\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS signals (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp TEXT NOT NULL,\n                symbol TEXT NOT NULL,\n                signal TEXT NOT NULL,\n                price REAL NOT NULL,\n                confidence REAL NOT NULL,\n                reason TEXT,\n                indicators TEXT\n            )\n        ''')\n        \n        # 创建性能记录表\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS performance (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp TEXT NOT NULL,\n                total_value REAL NOT NULL,\n                cash REAL NOT NULL,\n                positions_value REAL NOT NULL,\n                daily_return REAL,\n                cumulative_return REAL\n            )\n        ''')\n        \n        conn.commit()\n        conn.close()\n    \n    def save_trade(self, trade_data: Dict[str, Any]):\n        """保存交易记录"""\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute('''\n            INSERT INTO trades (timestamp, symbol, side, quantity, price, value, commission, strategy, signal_confidence)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n        ''', (\n            trade_data['timestamp'],\n            trade_data['symbol'],\n            trade_data['side'],\n            trade_data['quantity'],\n            trade_data['price'],\n            trade_data['value'],\n            trade_data.get('commission', 0),\n            trade_data.get('strategy', ''),\n            trade_data.get('signal_confidence', 0)\n        ))\n        \n        conn.commit()\n        conn.close()\n    \n    def save_signal(self, signal: TradingSignal, symbol: str):\n        """保存信号记录"""\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute('''\n            INSERT INTO signals (timestamp, symbol, signal, price, confidence, reason, indicators)\n            VALUES (?, ?, ?, ?, ?, ?, ?)\n        ''', (\n            signal.timestamp.isoformat(),\n            symbol,\n            signal.signal,\n            signal.price,\n            signal.confidence,\n            signal.reason,\n            json.dumps(signal.indicators)\n        ))\n        \n        conn.commit()\n        conn.close()\n    \n    def save_performance(self, performance_data: Dict[str, Any]):\n        """保存性能记录"""\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute('''\n            INSERT INTO performance (timestamp, total_value, cash, positions_value, daily_return, cumulative_return)\n            VALUES (?, ?, ?, ?, ?, ?)\n        ''', (\n            performance_data['timestamp'],\n            performance_data['total_value'],\n            performance_data['cash'],\n            performance_data['positions_value'],\n            performance_data.get('daily_return', 0),\n            performance_data.get('cumulative_return', 0)\n        ))\n        \n        conn.commit()\n        conn.close()\n\nclass Position:\n    """持仓信息"""\n    \n    def __init__(self, symbol: str, quantity: float, avg_price: float):\n        self.symbol = symbol\n        self.quantity = quantity\n        self.avg_price = avg_price\n        self.current_price = avg_price\n        self.unrealized_pnl = 0.0\n    \n    def update_price(self, price: float):\n        """更新当前价格"""\n        self.current_price = price\n        self.unrealized_pnl = (price - self.avg_price) * self.quantity\n    \n    @property\n    def market_value(self) -> float:\n        """市场价值"""\n        return self.current_price * abs(self.quantity)\n\nclass Order:\n    """订单信息"""\n    \n    def __init__(self, symbol: str, side: str, quantity: float, price: float):\n        self.symbol = symbol\n        self.side = side  # BUY, SELL\n        self.quantity = quantity\n        self.price = price\n        self.timestamp = datetime.now()\n        self.status = "FILLED"  # 简化处理，假设立即成交\n\nclass AdvancedStrategy:\n    """高级策略基类"""\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.indicators_cache = {}\n    \n    def calculate_rsi(self, prices: List[float], period: int = 14) -> float:\n        """计算RSI指标"""\n        if len(prices) < period + 1:\n            return 50.0\n        \n        deltas = np.diff(prices)\n        gains = np.where(deltas > 0, deltas, 0)\n        losses = np.where(deltas < 0, -deltas, 0)\n        \n        avg_gain = np.mean(gains[-period:])\n        avg_loss = np.mean(losses[-period:])\n        \n        if avg_loss == 0:\n            return 100.0\n        \n        rs = avg_gain / avg_loss\n        rsi = 100 - (100 / (1 + rs))\n        return rsi\n    \n    def calculate_ma(self, prices: List[float], period: int) -> float:\n        """计算移动平均线"""\n        if len(prices) < period:\n            return prices[-1] if prices else 0.0\n        return np.mean(prices[-period:])\n    \n    def calculate_macd(self, prices: List[float], fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[float, float, float]:\n        """计算MACD指标"""\n        if len(prices) < slow:\n            return 0.0, 0.0, 0.0\n        \n        ema_fast = self.calculate_ema(prices, fast)\n        ema_slow = self.calculate_ema(prices, slow)\n        macd_line = ema_fast - ema_slow\n        \n        # 简化信号线计算\n        signal_line = macd_line * 0.9  # 简化处理\n        histogram = macd_line - signal_line\n        \n        return macd_line, signal_line, histogram\n    \n    def calculate_ema(self, prices: List[float], period: int) -> float:\n        """计算指数移动平均线"""\n        if len(prices) < period:\n            return np.mean(prices) if prices else 0.0\n        \n        multiplier = 2 / (period + 1)\n        ema = prices[0]\n        \n        for price in prices[1:]:\n            ema = (price * multiplier) + (ema * (1 - multiplier))\n        \n        return ema\n    \n    def generate_signal(self, symbol: str, price_data: List[float]) -> TradingSignal:\n        """生成交易信号"""\n        current_price = price_data[-1]\n        \n        # 计算技术指标\n        rsi = self.calculate_rsi(price_data, self.config['strategy']['rsi_period'])\n        ma_short = self.calculate_ma(price_data, self.config['strategy']['ma_short'])\n        ma_long = self.calculate_ma(price_data, self.config['strategy']['ma_long'])\n        macd, macd_signal, macd_hist = self.calculate_macd(price_data)\n        \n        # 信号逻辑\n        signals = []\n        reasons = []\n        \n        # RSI信号\n        if rsi < self.config['strategy']['rsi_oversold']:\n            signals.append('BUY')\n            reasons.append(f'RSI超卖({rsi:.1f})')\n        elif rsi > self.config['strategy']['rsi_overbought']:\n            signals.append('SELL')\n            reasons.append(f'RSI超买({rsi:.1f})')\n        \n        # 均线信号\n        if ma_short > ma_long * 1.01:\n            signals.append('BUY')\n            reasons.append('短期均线上穿长期均线')\n        elif ma_short < ma_long * 0.99:\n            signals.append('SELL')\n            reasons.append('短期均线下穿长期均线')\n        \n        # MACD信号\n        if macd > macd_signal and macd_hist > 0:\n            signals.append('BUY')\n            reasons.append('MACD金叉')\n        elif macd < macd_signal and macd_hist < 0:\n            signals.append('SELL')\n            reasons.append('MACD死叉')\n        \n        # 综合信号\n        if not signals:\n            final_signal = 'HOLD'\n            confidence = 0.5\n            reason = '无明确信号'\n        else:\n            buy_count = signals.count('BUY')\n            sell_count = signals.count('SELL')\n            \n            if buy_count > sell_count:\n                final_signal = 'BUY'\n                confidence = min(0.9, 0.5 + buy_count * 0.2)\n            elif sell_count > buy_count:\n                final_signal = 'SELL'\n                confidence = min(0.9, 0.5 + sell_count * 0.2)\n            else:\n                final_signal = 'HOLD'\n                confidence = 0.5\n            \n            reason = '; '.join(reasons)\n        \n        indicators = {\n            'rsi': rsi,\n            'ma_short': ma_short,\n            'ma_long': ma_long,\n            'macd': macd,\n            'macd_signal': macd_signal,\n            'macd_histogram': macd_hist\n        }\n        \n        return TradingSignal(\n            signal=final_signal,\n            price=current_price,\n            confidence=confidence,\n            timestamp=datetime.now(),\n            reason=reason,\n            indicators=indicators\n        )\n\nclass IntegratedTradingSystem:\n    """集成交易系统"""\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.db_manager = DatabaseManager()\n        self.strategy = AdvancedStrategy(config)\n        \n        # 投资组合状态\n        self.cash = config.get('backtest', {}).get('initial_balance', 100000)\n        self.positions: Dict[str, Position] = {}\n        self.orders: List[Order] = []\n        self.total_value = self.cash\n        self.equity_curve = []\n        \n        # 性能统计\n        self.trades_count = 0\n        self.winning_trades = 0\n        self.losing_trades = 0\n        self.total_profit = 0.0\n        self.total_loss = 0.0\n        self.max_drawdown = 0.0\n        self.peak_value = self.cash\n        \n        logger.info(f"交易系统初始化完成，初始资金: {self.cash}")\n    \n    def get_market_data(self, symbol: str, limit: int = 100) -> List[float]:\n        """获取市场数据（模拟）"""\n        # 生成模拟价格数据\n        base_price = 50000 if symbol == 'BTCUSDT' else 3000\n        prices = []\n        current_price = base_price\n        \n        for i in range(limit):\n            # 随机游走\n            change = np.random.normal(0, 0.02)\n            current_price *= (1 + change)\n            prices.append(current_price)\n        \n        return prices\n    \n    def update_portfolio_value(self):\n        """更新投资组合价值"""\n        positions_value = 0.0\n        \n        for position in self.positions.values():\n            # 获取当前价格（模拟）\n            current_prices = self.get_market_data(position.symbol, 1)\n            if current_prices:\n                position.update_price(current_prices[-1])\n                positions_value += position.market_value\n        \n        self.total_value = self.cash + positions_value\n        \n        # 更新最大回撤\n        if self.total_value > self.peak_value:\n            self.peak_value = self.total_value\n        else:\n            drawdown = (self.peak_value - self.total_value) / self.peak_value\n            self.max_drawdown = max(self.max_drawdown, drawdown)\n    \n    def execute_trade(self, symbol: str, side: str, quantity: float, price: float) -> Optional[Order]:\n        """执行交易"""\n        try:\n            trade_value = quantity * price\n            commission = trade_value * 0.001  # 0.1% 手续费\n            \n            if side == 'BUY':\n                if self.cash < trade_value + commission:\n                    logger.warning(f"资金不足，无法买入 {quantity} {symbol}")\n                    return None\n                \n                # 执行买入\n                self.cash -= (trade_value + commission)\n                \n                if symbol in self.positions:\n                    # 更新现有持仓\n                    old_pos = self.positions[symbol]\n                    total_quantity = old_pos.quantity + quantity\n                    avg_price = ((old_pos.avg_price * old_pos.quantity) + (price * quantity)) / total_quantity\n                    self.positions[symbol] = Position(symbol, total_quantity, avg_price)\n                else:\n                    # 创建新持仓\n                    self.positions[symbol] = Position(symbol, quantity, price)\n            \n            elif side == 'SELL':\n                if symbol not in self.positions or self.positions[symbol].quantity < quantity:\n                    logger.warning(f"持仓不足，无法卖出 {quantity} {symbol}")\n                    return None\n                \n                # 执行卖出\n                self.cash += (trade_value - commission)\n                \n                # 更新持仓\n                old_pos = self.positions[symbol]\n                if old_pos.quantity == quantity:\n                    # 全部卖出\n                    del self.positions[symbol]\n                else:\n                    # 部分卖出\n                    self.positions[symbol].quantity -= quantity\n                \n                # 计算盈亏\n                pnl = (price - old_pos.avg_price) * quantity - commission\n                if pnl > 0:\n                    self.winning_trades += 1\n                    self.total_profit += pnl\n                else:\n                    self.losing_trades += 1\n                    self.total_loss += abs(pnl)\n            \n            # 创建订单记录\n            order = Order(symbol, side, quantity, price)\n            self.orders.append(order)\n            self.trades_count += 1\n            \n            logger.info(f"交易执行: {side} {quantity} {symbol} @ {price}, 手续费: {commission:.2f}")\n            return order\n            \n        except Exception as e:\n            logger.error(f"交易执行失败: {e}")\n            return None\n    \n    def generate_performance_report(self) -> Dict[str, Any]:\n        """生成性能报告"""\n        self.update_portfolio_value()\n        \n        initial_balance = self.config.get('backtest', {}).get('initial_balance', 100000)\n        total_return = (self.total_value - initial_balance) / initial_balance\n        \n        win_rate = self.winning_trades / max(1, self.trades_count)\n        avg_win = self.total_profit / max(1, self.winning_trades)\n        avg_loss = self.total_loss / max(1, self.losing_trades)\n        profit_factor = self.total_profit / max(0.01, self.total_loss)\n        \n        return {\n            'initial_balance': initial_balance,\n            'final_balance': self.total_value,\n            'total_return': total_return,\n            'total_return_pct': total_return * 100,\n            'total_trades': self.trades_count,\n            'winning_trades': self.winning_trades,\n            'losing_trades': self.losing_trades,\n            'win_rate': win_rate,\n            'win_rate_pct': win_rate * 100,\n            'avg_win': avg_win,\n            'avg_loss': avg_loss,\n            'profit_factor': profit_factor,\n            'max_drawdown': self.max_drawdown,\n            'max_drawdown_pct': self.max_drawdown * 100,\n            'sharpe_ratio': self.calculate_sharpe_ratio(),\n            'current_cash': self.cash,\n            'positions_count': len(self.positions)\n        }\n    \n    def calculate_sharpe_ratio(self) -> float:\n        """计算夏普比率"""\n        if len(self.equity_curve) < 2:\n            return 0.0\n        \n        returns = []\n        for i in range(1, len(self.equity_curve)):\n            ret = (self.equity_curve[i]['total_value'] - self.equity_curve[i-1]['total_value']) / self.equity_curve[i-1]['total_value']\n            returns.append(ret)\n        \n        if not returns:\n            return 0.0\n        \n        avg_return = np.mean(returns)\n        std_return = np.std(returns)\n        \n        if std_return == 0:\n            return 0.0\n        \n        # 假设无风险利率为3%年化\n        risk_free_rate = 0.03 / 252  # 日化\n        sharpe = (avg_return - risk_free_rate) / std_return\n        \n        return sharpe * np.sqrt(252)  # 年化\n"}}